<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>knncolle: knncolle::Hnsw&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">knncolle
   </div>
   <div id="projectbrief">Collection of KNN methods in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>knncolle</b></li><li class="navelem"><a class="el" href="classknncolle_1_1Hnsw.html">Hnsw</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classknncolle_1_1Hnsw-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">knncolle::Hnsw&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Perform an approximate nearest neighbor search with HNSW.  
 <a href="classknncolle_1_1Hnsw.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Hnsw_8hpp_source.html">Hnsw.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for knncolle::Hnsw&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classknncolle_1_1Hnsw__inherit__graph.png" border="0" usemap="#aknncolle_1_1Hnsw_3_01SPACE_00_01INDEX__t_00_01DISTANCE__t_00_01QUERY__t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aknncolle_1_1Hnsw_3_01SPACE_00_01INDEX__t_00_01DISTANCE__t_00_01QUERY__t_01_4_inherit__map" id="aknncolle_1_1Hnsw_3_01SPACE_00_01INDEX__t_00_01DISTANCE__t_00_01QUERY__t_01_4_inherit__map">
<area shape="rect" title="Perform an approximate nearest neighbor search with HNSW." alt="" coords="17,93,186,148"/>
<area shape="rect" href="classknncolle_1_1Base.html" title="Virtual base class defining the knncolle interface." alt="" coords="5,5,197,45"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for knncolle::Hnsw&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classknncolle_1_1Hnsw__coll__graph.png" border="0" usemap="#aknncolle_1_1Hnsw_3_01SPACE_00_01INDEX__t_00_01DISTANCE__t_00_01QUERY__t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aknncolle_1_1Hnsw_3_01SPACE_00_01INDEX__t_00_01DISTANCE__t_00_01QUERY__t_01_4_coll__map" id="aknncolle_1_1Hnsw_3_01SPACE_00_01INDEX__t_00_01DISTANCE__t_00_01QUERY__t_01_4_coll__map">
<area shape="rect" title="Perform an approximate nearest neighbor search with HNSW." alt="" coords="17,93,186,148"/>
<area shape="rect" href="classknncolle_1_1Base.html" title="Virtual base class defining the knncolle interface." alt="" coords="5,5,197,45"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structknncolle_1_1Hnsw_1_1Defaults.html">Defaults</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a47ebc6910b2e7eedb442b95124365e44"><td class="memItemLeft" align="right" valign="top">INDEX_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Hnsw.html#a47ebc6910b2e7eedb442b95124365e44">nobs</a> () const</td></tr>
<tr class="separator:a47ebc6910b2e7eedb442b95124365e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669e7734e90da6fe0d11d485bd6abaef"><td class="memItemLeft" align="right" valign="top">INDEX_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Hnsw.html#a669e7734e90da6fe0d11d485bd6abaef">ndim</a> () const</td></tr>
<tr class="separator:a669e7734e90da6fe0d11d485bd6abaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636c453927fa8b4d8260e754d548ccf1"><td class="memTemplParams" colspan="2">template&lt;typename INPUT &gt; </td></tr>
<tr class="memitem:a636c453927fa8b4d8260e754d548ccf1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Hnsw.html#a636c453927fa8b4d8260e754d548ccf1">Hnsw</a> (INDEX_t <a class="el" href="classknncolle_1_1Hnsw.html#a669e7734e90da6fe0d11d485bd6abaef">ndim</a>, INDEX_t <a class="el" href="classknncolle_1_1Hnsw.html#a47ebc6910b2e7eedb442b95124365e44">nobs</a>, const INPUT *vals, int nlinks=<a class="el" href="structknncolle_1_1Hnsw_1_1Defaults.html#ac2a05b9b95f3355dbcf166cdb306f449">Defaults::nlinks</a>, int ef_construction=<a class="el" href="structknncolle_1_1Hnsw_1_1Defaults.html#ad0a1e554102c0a56e912439e3e078856">Defaults::ef_construction</a>, int ef_search=<a class="el" href="structknncolle_1_1Hnsw_1_1Defaults.html#ac443aa1067f75bc4e7e20c2d6366e044">Defaults::ef_search</a>)</td></tr>
<tr class="separator:a636c453927fa8b4d8260e754d548ccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c4399f93b95d12590d7a4373aa3042"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; INDEX_t, DISTANCE_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Hnsw.html#ac7c4399f93b95d12590d7a4373aa3042">find_nearest_neighbors</a> (INDEX_t index, int k) const</td></tr>
<tr class="separator:ac7c4399f93b95d12590d7a4373aa3042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8435fbf5f415a8c98947fd9ffeb4ce66"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; INDEX_t, DISTANCE_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Hnsw.html#a8435fbf5f415a8c98947fd9ffeb4ce66">find_nearest_neighbors</a> (const QUERY_t *query, int k) const</td></tr>
<tr class="separator:a8435fbf5f415a8c98947fd9ffeb4ce66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81dd12010e96fe44a54592e1509a562"><td class="memItemLeft" align="right" valign="top">const QUERY_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Hnsw.html#aa81dd12010e96fe44a54592e1509a562">observation</a> (INDEX_t index, QUERY_t *buffer) const</td></tr>
<tr class="separator:aa81dd12010e96fe44a54592e1509a562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59601c71d14fa688dc905464b82b86c6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; QUERY_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Hnsw.html#a59601c71d14fa688dc905464b82b86c6">observation</a> (INDEX_t index) const</td></tr>
<tr class="separator:a59601c71d14fa688dc905464b82b86c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71a6194f8c10982817d0f7a2d1e37a6"><td class="memItemLeft" align="right" valign="top">virtual INDEX_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Base.html#af71a6194f8c10982817d0f7a2d1e37a6">nobs</a> () const =0</td></tr>
<tr class="separator:af71a6194f8c10982817d0f7a2d1e37a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544049d99949710f35a067fc7e48c0a7"><td class="memItemLeft" align="right" valign="top">virtual INDEX_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Base.html#a544049d99949710f35a067fc7e48c0a7">ndim</a> () const =0</td></tr>
<tr class="separator:a544049d99949710f35a067fc7e48c0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a58c1e4d737ce01515129c5b5257327"><td class="memItemLeft" align="right" valign="top">virtual const QUERY_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Base.html#a2a58c1e4d737ce01515129c5b5257327">observation</a> (INDEX_t index, QUERY_t *buffer) const =0</td></tr>
<tr class="separator:a2a58c1e4d737ce01515129c5b5257327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7616f71913cd269283b5669a7d01176"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; QUERY_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Base.html#ab7616f71913cd269283b5669a7d01176">observation</a> (INDEX_t index) const</td></tr>
<tr class="separator:ab7616f71913cd269283b5669a7d01176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966ab9bdec2815809241637b1ab90334"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; INDEX_t, DISTANCE_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Base.html#a966ab9bdec2815809241637b1ab90334">find_nearest_neighbors</a> (INDEX_t index, int k) const =0</td></tr>
<tr class="separator:a966ab9bdec2815809241637b1ab90334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a21b15908c0c80094402cce2e496626"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; INDEX_t, DISTANCE_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle_1_1Base.html#a1a21b15908c0c80094402cce2e496626">find_nearest_neighbors</a> (const QUERY_t *query, int k) const =0</td></tr>
<tr class="separator:a1a21b15908c0c80094402cce2e496626"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class SPACE, typename INDEX_t = int, typename DISTANCE_t = double, typename QUERY_t = DISTANCE_t&gt;<br />
class knncolle::Hnsw&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt;</div><p>Perform an approximate nearest neighbor search with HNSW. </p>
<p>In the HNSW algorithm (Malkov and Yashunin, 2016), each point is a node in a "nagivable small world" graph. The nearest neighbor search proceeds by starting at a node and walking through the graph to obtain closer neighbors to a given query point. Nagivable small world graphs are used to maintain connectivity across the data set by creating links between distant points. This speeds up the search by ensuring that the algorithm does not need to take many small steps to move from one cluster to another. The HNSW algorithm extends this idea by using a hierarchy of such graphs containing links of different lengths, which avoids wasting time on small steps in the early stages of the search where the current node position is far from the query.</p>
<p>Note that, to improve reproducibility across architectures, we have disabled manual vectorization of the distance calculations by default. This can be restored by defining the <code>KNNCOLLE_MANUAL_VECTORIZATION</code> macro.</p>
<dl class="section see"><dt>See also</dt><dd>Malkov YA, Yashunin DA (2016). Efficient and robust approximate nearest neighbor search using Hierarchical Navigable Small World graphs. <em>arXiv</em>. <a href="https://arxiv.org/abs/1603.09320">https://arxiv.org/abs/1603.09320</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DISTANCE</td><td>An <b>hnswlib</b>-derived class to compute the distance between vectors. Note that this is not the same as the classes in <code><a class="el" href="distances_8hpp.html" title="Classes for distance calculations.">distances.hpp</a></code>. </td></tr>
    <tr><td class="paramname">INDEX_t</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">DISTANCE_t</td><td>Floating point type for the distances. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a636c453927fa8b4d8260e754d548ccf1" name="a636c453927fa8b4d8260e754d548ccf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636c453927fa8b4d8260e754d548ccf1">&#9670;&#160;</a></span>Hnsw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPACE , typename INDEX_t  = int, typename DISTANCE_t  = double, typename QUERY_t  = DISTANCE_t&gt; </div>
<div class="memtemplate">
template&lt;typename INPUT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classknncolle_1_1Hnsw.html">knncolle::Hnsw</a>&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt;::Hnsw </td>
          <td>(</td>
          <td class="paramtype">INDEX_t&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INDEX_t&#160;</td>
          <td class="paramname"><em>nobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const INPUT *&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlinks</em> = <code><a class="el" href="structknncolle_1_1Hnsw_1_1Defaults.html#ac2a05b9b95f3355dbcf166cdb306f449">Defaults::nlinks</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ef_construction</em> = <code><a class="el" href="structknncolle_1_1Hnsw_1_1Defaults.html#ad0a1e554102c0a56e912439e3e078856">Defaults::ef_construction</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ef_search</em> = <code><a class="el" href="structknncolle_1_1Hnsw_1_1Defaults.html#ac443aa1067f75bc4e7e20c2d6366e044">Defaults::ef_search</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramname">nobs</td><td>Number of observations. </td></tr>
    <tr><td class="paramname">vals</td><td>Pointer to an array of length <code>ndim * nobs</code>, corresponding to a dimension-by-observation matrix in column-major format, i.e., contiguous elements belong to the same observation. </td></tr>
    <tr><td class="paramname">nlinks</td><td>Number of bidirectional links for each node. This is equivalent to the <code>M</code> parameter in the underlying <b>hnswlib</b> library, see <a href="https://github.com/nmslib/hnswlib/blob/master/ALGO_PARAMS.md#construction-parameters">here</a> for details. </td></tr>
    <tr><td class="paramname">ef_construction</td><td>Size of the dynamic list of nearest neighbors during index construction. This controls the trade-off between indexing time and accuracy and is equivalent to the <code>ef_construct</code> parameter in the underlying <b>hnswlib</b> library, see <a href="https://github.com/nmslib/hnswlib/blob/master/ALGO_PARAMS.md#construction-parameters">here</a> for details. </td></tr>
    <tr><td class="paramname">ef_search</td><td>Size of the dynamic list of nearest neighbors during searching. This controls the trade-off between search speed and accuracy and is equivalent to the <code>ef</code> parameter in the underlying <b>hnswlib</b> library, see <a href="https://github.com/nmslib/hnswlib/blob/master/ALGO_PARAMS.md#search-parameters">here</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INPUT</td><td>Floating-point type of the input data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8435fbf5f415a8c98947fd9ffeb4ce66" name="a8435fbf5f415a8c98947fd9ffeb4ce66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8435fbf5f415a8c98947fd9ffeb4ce66">&#9670;&#160;</a></span>find_nearest_neighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPACE , typename INDEX_t  = int, typename DISTANCE_t  = double, typename QUERY_t  = DISTANCE_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; INDEX_t, DISTANCE_t &gt; &gt; <a class="el" href="classknncolle_1_1Hnsw.html">knncolle::Hnsw</a>&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt;::find_nearest_neighbors </td>
          <td>(</td>
          <td class="paramtype">const QUERY_t *&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the nearest neighbors of a new observation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Pointer to an array of length equal to <code>ndims()</code>, containing the coordinates of the query point. </td></tr>
    <tr><td class="paramname">k</td><td>The number of neighbors to identify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of (index, distance) pairs containing the identities of the nearest neighbors in order of increasing distance. Length is at most <code>k</code> but may be shorter if the total number of observations is less than <code>k</code>. </dd></dl>

<p>Implements <a class="el" href="classknncolle_1_1Base.html#a1a21b15908c0c80094402cce2e496626">knncolle::Base&lt; INDEX_t, DISTANCE_t, QUERY_t &gt;</a>.</p>

</div>
</div>
<a id="ac7c4399f93b95d12590d7a4373aa3042" name="ac7c4399f93b95d12590d7a4373aa3042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c4399f93b95d12590d7a4373aa3042">&#9670;&#160;</a></span>find_nearest_neighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPACE , typename INDEX_t  = int, typename DISTANCE_t  = double, typename QUERY_t  = DISTANCE_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; INDEX_t, DISTANCE_t &gt; &gt; <a class="el" href="classknncolle_1_1Hnsw.html">knncolle::Hnsw</a>&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt;::find_nearest_neighbors </td>
          <td>(</td>
          <td class="paramtype">INDEX_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the nearest neighbors of the <code>index</code>-th observation in the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the observation of interest. This should be non-negative and less than the total number of observations in <code><a class="el" href="classknncolle_1_1Hnsw.html#a47ebc6910b2e7eedb442b95124365e44">nobs()</a></code>. </td></tr>
    <tr><td class="paramname">k</td><td>The number of neighbors to identify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of (index, distance) pairs containing the identities of the nearest neighbors in order of increasing distance. Length is at most <code>k</code> but may be shorter if the total number of observations is less than <code>k + 1</code>. </dd></dl>

<p>Implements <a class="el" href="classknncolle_1_1Base.html#a966ab9bdec2815809241637b1ab90334">knncolle::Base&lt; INDEX_t, DISTANCE_t, QUERY_t &gt;</a>.</p>

</div>
</div>
<a id="a669e7734e90da6fe0d11d485bd6abaef" name="a669e7734e90da6fe0d11d485bd6abaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669e7734e90da6fe0d11d485bd6abaef">&#9670;&#160;</a></span>ndim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPACE , typename INDEX_t  = int, typename DISTANCE_t  = double, typename QUERY_t  = DISTANCE_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INDEX_t <a class="el" href="classknncolle_1_1Hnsw.html">knncolle::Hnsw</a>&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt;::ndim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of dimensions. </p>

<p>Implements <a class="el" href="classknncolle_1_1Base.html#a544049d99949710f35a067fc7e48c0a7">knncolle::Base&lt; INDEX_t, DISTANCE_t, QUERY_t &gt;</a>.</p>

</div>
</div>
<a id="a47ebc6910b2e7eedb442b95124365e44" name="a47ebc6910b2e7eedb442b95124365e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ebc6910b2e7eedb442b95124365e44">&#9670;&#160;</a></span>nobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPACE , typename INDEX_t  = int, typename DISTANCE_t  = double, typename QUERY_t  = DISTANCE_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INDEX_t <a class="el" href="classknncolle_1_1Hnsw.html">knncolle::Hnsw</a>&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt;::nobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of observations in the dataset to be searched. </p>

<p>Implements <a class="el" href="classknncolle_1_1Base.html#af71a6194f8c10982817d0f7a2d1e37a6">knncolle::Base&lt; INDEX_t, DISTANCE_t, QUERY_t &gt;</a>.</p>

</div>
</div>
<a id="a59601c71d14fa688dc905464b82b86c6" name="a59601c71d14fa688dc905464b82b86c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59601c71d14fa688dc905464b82b86c6">&#9670;&#160;</a></span>observation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPACE , typename INDEX_t  = int, typename DISTANCE_t  = double, typename QUERY_t  = DISTANCE_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; QUERY_t &gt; <a class="el" href="classknncolle_1_1Hnsw.html">knncolle::Hnsw</a>&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt;::observation </td>
          <td>(</td>
          <td class="paramtype">INDEX_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the vector of coordinates for a given observation in the dataset. Type conversions may be performed if <code>QUERY_t</code> differs from the type of the internal data store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the observation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of coordinates. </dd></dl>

<p>Reimplemented from <a class="el" href="classknncolle_1_1Base.html#ab7616f71913cd269283b5669a7d01176">knncolle::Base&lt; INDEX_t, DISTANCE_t, QUERY_t &gt;</a>.</p>

</div>
</div>
<a id="aa81dd12010e96fe44a54592e1509a562" name="aa81dd12010e96fe44a54592e1509a562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81dd12010e96fe44a54592e1509a562">&#9670;&#160;</a></span>observation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SPACE , typename INDEX_t  = int, typename DISTANCE_t  = double, typename QUERY_t  = DISTANCE_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const QUERY_t * <a class="el" href="classknncolle_1_1Hnsw.html">knncolle::Hnsw</a>&lt; SPACE, INDEX_t, DISTANCE_t, QUERY_t &gt;::observation </td>
          <td>(</td>
          <td class="paramtype">INDEX_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QUERY_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the vector of coordinates for a given observation in the dataset. Type conversions may be performed if <code>QUERY_t</code> differs from the type of the internal data store.</p>
<p><code>buffer</code> may not be filled if a pointer to the internal data store can be returned directly. This can be assumed to be the case if the return address is not the same as <code>buffer</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the observation. This should be non-negative and less than the total number of observations in <code><a class="el" href="classknncolle_1_1Hnsw.html#a47ebc6910b2e7eedb442b95124365e44">nobs()</a></code>. </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer to store the coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an array containing the coordinate vector. </dd></dl>

<p>Implements <a class="el" href="classknncolle_1_1Base.html#a2a58c1e4d737ce01515129c5b5257327">knncolle::Base&lt; INDEX_t, DISTANCE_t, QUERY_t &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>knncolle/Hnsw/<a class="el" href="Hnsw_8hpp_source.html">Hnsw.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
